# AOP(Aspect Oriented Programming)관점 지향 프로그래밍

어플리케이션을 바라보는 관점을 하나 하나의 기능에서 횡단 관심사 관점으로 달리 보는 것을 관점 지향 프로그래밍이라고 한다.</br>

그럼 무엇으로의 횡단 관심사일까? </br>
어플리케이션은 크게 2가지 기능으로 나눌 수 있다.</br>
핵심 기능과 부가기능으로 말이다. 여기서 핵심 기능이란 무엇일까? 비즈니스 로직으로 볼 수 있다.</br>
우리가 여태까지 해온 Order의 기능들은 핵심 기능으로 볼 수 있지만 로그를 남기는 기능은 부가 기능이다.</br>
이 부가기능들을 모듈화 해서 어디에 어떤 기능을 제공할지 이야기하는 것이 관점 지향 프로그래밍이라고 할 수 있다.</br>

## AOP 적용 방식

AOP은 어떤 방식으로 적용 될 수 있을까?
AOP는 크게 3가지 방법으로 적용된다.</br>

* 컴파일 시점
* 클래스 로딩 시점
* 런타임 시점

### 컴파일 시점

컴파일 시점은 AspectJ가 제공하는 컴파일러를 사용해서 해당 부가기능 로직이 어디에 적용 되는지 판단하고 적용 대상일 경우 부가 기능 로직을 적용하는 방식이다.</br>

### 클래스 로딩 시점

자바는 클래스 파일을 JVM 클래스 로더에 보관한다.</br> 클래스 파일 보관하기 전에 클래스 파일을 조작한 다음 JVM에 올리는데 이 때 AspectJ가 클래스 로더 조작기로 파일을 수정후 JVM에 올리는
방식이다.</br>

### 런타임 시점

런타임 시점에서 스프링과 같은 컨테이너의 도움을 받아 부가 기능을 넣는 방식이다.</br>
컴파일 시점과 클래스 로딩 시점에서는 실제 대상 코드에 Aspect를 통한 부가 기능 호출 코드가 포함 된다.</br>
다시 말해서 실제 코드가 변경된다.</br> 하지만 런타임 시점에서는 실제 코드 대상이 유지되므로 프록시를 통해서 부가 기능을 사용할 수 있게된다.</br>
AOP 적용 위치
컴파일과 클래스 로딩 시점은 실행 위치 뿐만 아니라 생성자, 필드 값, static 메서드, 메서드 다양한 위치에 적용이 가능하다.</br>
왜냐하면 AOP가 바이트코드를 실제 조작하기 때문에 모든 지점에서 사용가능하다.</br>
하지만 런타임 시점은 다르다 프록시를 사용해야만 하기 때문에 메서드 실행에만 제한된다.</br>

## AOP 용어

AOP용어는 조인포인트, 포인트컷, 타겟, 어드바이스, 에스펙트, 어드바이저, 위빙, AOP프록시가 있다.</br>

### 조인포인트(Join Point)

* 어드바이스가 적용될 수 있는 위치를 말한다.</br>
* 조인 포인트 자체가 어디서 쓰이는 개념이 아닌 추상적인 개념이다.</br>
* EX) 스프링 AOP의 조인 포인트는? -> 프록시를 사용하므로 메소드 실행 시점

### 포인트컷(Pointcut)

* 조인 포인트 중에서 어드바이스가 적용될 위치를 선별하는 기능
* AspectJ 표현식을 사용해서 지정

### 타겟(Target)

* 어드바이스를 받는 객체, 포인트컷으로 결정

### 어드바이스(Advice)

* 부가 기능이 담겨져 있음
* 선별된 조인 포인트에서 Aspect에 의해 취해지는 조치

### 애스팩트(Aspect)

* 어드바이스 + 포인트컷을 모듈화 한 것
* 여러 어드바이스와 포인트 컷이 함께 존재 가능

### 어드바이저(Advisor)

* 하나의 어드바이스와 하나의 포인트 컷으로 구성
* 스프링 AOP에서만 사용되는 특별한 용어

### 위빙(Weaving)

* 포인트컷으로 결정한 타겟의 조인 포인트에 어드바이스를 적용하는 것

### AOP 프록시

* AOP 기능을 구현하기 위해 만든 프록시 객체</br>

## AOP 구현

Spring에서는 여러 애노테이션으로 AOP를 구현 가능하다.</br>

### @Aspect

* Spring Boot에서는 클래스에 @Aspect를 사용해서 AOP를 구현 가능하다.
* @Aspect는 Aspect라는 표식이지 컴포넌트 스캔의 대상이 되는건 아니다. 꼭 스프링 Bean 등록을 해줘야 한다.

### @Around

* @Around의 애노테이션 값은 AsepctJ 표현식을 사용한 포인트컷이 된다.
* @Around는 애노테이션 메서드는 어드바이스가 된다.

### @Pointcut

* @Around에 직접 넣을 수 도 있지만 @Pointcut을 사용해서 별도로 분리 가능하다.
* @Pointcut에 포인트컷 표현식을 사용한다.
* 메서드의 반환 타입은 void여야 하고 코드 내용은 비워두어야 한다.
* 외부에서 사용하려면 public을 사용해야한다.

### @Order

* 애스팩트에는 여러개의 어드바이스가 존재할 수 있다. 그럼 순서는? 이것을 해결하는 것이 @Order
* 메서드에 붙이는 것이 아닌 클래스에 붙인다. 근데 @Aspect는 클래스에 붙일 수 있다. 그래서 이럴 경우 내부 클래스로 별도로 구별해야한다.
* 안에 숫자를 넣어서 낮은 순서대로 순서대로 실행 가능

### 어드바이스 종류

어드바이스에는 @Around말고 다른 종류가 있는데

* @Around : 매서드 호출 전후에 수행, 조인 포인트 실행 여부 선택, 반환 값 변환, 예외 변환 등이 가능
* @Before : 조인 포인트 실행 이전에 실행
* @AfterReturning : 조인 포인트가 정상 완료 후 실행
* @AfterThrowing : 메서드가 예외를 던지는 경우 실행
* @After : 조인 포인트가 정상 또는 예외에 관계없이 실행(finally)

@Around를 제외 하고는 실제로 변경할 수 있지는 않다. 그럼 왜 사용할까?</br>
코드의 의도가 명확하게 드러나며, 제약 함으로써 실수를 미연에 방지할 수 있다. 

